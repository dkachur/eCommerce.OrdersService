name: CI/CD - Build, Push, Deploy

on:
  push:
    branches: 
      - main
      - dev

env:
  IMAGE_NAME: orders-microservice

jobs:     
  build-and-push:
    name: Build and Push Image
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Azure
        uses: azure/login@v2
        with:
            creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Log in to ACR
        run: |
          az acr login --name ${{ secrets.ACR_NAME }}

      - name: Build and Push Docker image
        run: |
          ACR_IMAGE_NAME=${{ secrets.ACR_NAME }}.azurecr.io/$IMAGE_NAME
          BRANCH_TAG=${{ github.ref_name }}
          UNIQUE_TAG=${{ github.run_number }}

          docker build -f eCommerce.OrdersService.API/Dockerfile \
            -t $ACR_IMAGE_NAME:$BRANCH_TAG \
            -t $ACR_IMAGE_NAME:$BRANCH_TAG-build-$UNIQUE_TAG .

          docker push $ACR_IMAGE_NAME:$BRANCH_TAG
          docker push $ACR_IMAGE_NAME:$BRANCH_TAG-build-$UNIQUE_TAG


  deploy:
    name: Deploy to AKS
    runs-on: ubuntu-latest
    needs: build-and-push
    
    steps:
      - name: Checkout (for kubectl manifests access)
        uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials --resource-group ${{ secrets.AKS_RESOURCE_GROUP }} --name ${{ secrets.AKS_CLUSTER_NAME }} --overwrite-existing
        env:
          AZURE_CORE_DISABLE_CONNECTION_VERIFICATION: 'true'

      - name: Ensure namespace exists
        run: |
          if [ "${GITHUB_REF#refs/heads/}" = "main" ]; then
            NS="ecommerce-main"
          else
            NS="ecommerce-dev"
          fi
          kubectl get ns ${NS} || kubectl create ns ${NS}
          echo "KUBE_NAMESPACE=${NS}" >> $GITHUB_ENV

      - name: Create Kubernetes secrets
        run: |
          kubectl -n ${KUBE_NAMESPACE} create secret generic mongo-secret \
            --from-literal=MONGO_USER=${{ secrets.MONGO_USER }} \
            --from-literal=MONGO_PASS=${{ secrets.MONGO_PASS }} \
            --dry-run=client -o yaml | kubectl apply -f -
          kubectl -n ${KUBE_NAMESPACE} create secret generic rabbitmq-secret \
            --from-literal=RABBITMQ_USER=${{ secrets.RABBITMQ_USER }} \
            --from-literal=RABBITMQ_PASS=${{ secrets.RABBITMQ_PASS }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy - update image in existing Deployment or create new Deployment
        run: |
          IMAGE_TAG=${{ github.ref_name }}-build-${{ github.run_number }}
          sed "s|__IMAGE__|${{ secrets.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${IMAGE_TAG}|g" k8s/orders-deployment.yaml \
            | kubectl -n ${KUBE_NAMESPACE} apply -f -
          kubectl -n ${KUBE_NAMESPACE} apply -f k8s/orders-service.yaml

      - name: Wait rollout
        run: |
          DEPLOYMENT_NAME="orders-deployment"
          kubectl -n ${KUBE_NAMESPACE} rollout status deployment/${DEPLOYMENT_NAME} --timeout=180s
